package cd.backend.codegen;

import static cd.backend.codegen.RegisterManager.BASE_REG;
import static cd.backend.codegen.RegisterManager.STACK_REG;

import java.io.Writer;
import java.util.List;

import cd.Config;
import cd.Main;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast.ClassDecl;
import cd.ir.Ast.VarDecl;

public class AstCodeGenerator {

	protected RegsNeededVisitor rnv;
	
	protected ExprGenerator eg;
	protected StmtGenerator sg;
	
	protected final Main main;
	
	protected final AssemblyEmitter emit;
	protected final RegisterManager rm = new RegisterManager();
	
	protected static final String VAR_PREFIX = "var_";

	AstCodeGenerator(Main main, Writer out) {
		{
			initMethodData();
		}
		
		this.emit = new AssemblyEmitter(out);
		this.main = main;
		this.rnv = new RegsNeededVisitor();

		this.eg = new ExprGenerator(this);
		this.sg = new StmtGenerator(this);
	}

	protected void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
		return new AstCodeGenerator(main, out);
	}
	
	
	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into two sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * </ol>
	 */
	VTableManager vtableManager;		
	ObjectShapeManager objShapeManager;
	public void go(List<? extends ClassDecl> astRoots) {
		
		// TODO: rewrite these 2 classes
		vtableManager = new VTableManager(astRoots, this);		
		objShapeManager = new ObjectShapeManager(astRoots, vtableManager);
		
		emit.emitRaw(Config.DATA_INT_SECTION);
		vtableManager.emit();
		
		// Emit some useful string constants:
		emit.emitLabel("\tSTR_NL");
		emit.emitRaw("\t\t" + Config.DOT_STRING + " \"\\n\"");
		emit.emitLabel("\tSTR_D");
		emit.emitRaw("\t\t" + Config.DOT_STRING + " \"%d\"");
		
		// safe pointer for error exit
		emit.emitLabel("\tBASE_PT");
		emit.emitRaw("	.int 0");
		emit.emitLabel("\tSTACK_PT");
		emit.emitRaw("	.int 0");
		
		emit.emitRaw(Config.TEXT_SECTION);
		emit.emitCommentSection("start: Main-Class");

		emit.emit(".global", Config.MAIN);
		
		emit.emitRaw("");
		emit.emitLabel(Config.MAIN);
		
		//get the vtable
		VTable table = vtableManager.get("Main");
		
		//get the size and layout
		ObjectShape objShape = objShapeManager.get("Main");
		
		
		// prolog
		emit.emitComment("start: prolog");
		
		emit.emit("movl", STACK_REG, "STACK_PT");
		emit.emit("movl", BASE_REG, "BASE_PT");
		
		emit.emit("pushl", BASE_REG);// safe base pointer
		emit.emit("movl", STACK_REG, BASE_REG);// copy esp to ebp
		
		emit.emitComment("end: prolog");

		
		// Create Main object and safe its address to %eax
		emit.emitComment("Create Main object and safe its address to %eax");
		//emit.emit("movl", "$"+objShape.sizeInN(), "%eax"); 
		emit.emit("pushl", "$4" );    // arg2: size
		emit.emit("pushl", "$"+objShape.sizeInN() );  // arg1: n items
		emit.emit("call", "calloc");  // call calloc with args
		emit.emit("addl", "$8", "%esp");  // remove args from stack

		// %eax contains address of Main Object
		// now copy the pinter to the vtable to the Main Object
		emit.emitComment("copy the pinter to the vtable to the Main Object");
		emit.emit("movl", "$"+objShape.getAddr(), "(%eax)");
		
		// get label of the main method
		String label = table.getLabel("main").toString();
		
		emit.emit("pushl", "%eax");	      //set the target of main (arg0)
		emit.emit("call", label);		  //call main
		emit.emit("addl", "$4", "%esp");  // remove arg from stack
		
		
		// epilog
		emit.emit("movl", BASE_REG, STACK_REG);
		emit.emit("popl", BASE_REG);// restore old ebp
		
		// return with error code 0
		emit.emit("movl", "$0", Register.EAX);
		//emit.emitRaw("leave"); //TODO:Â not working with leave
		emit.emitRaw("ret");
		emit.emitCommentSection("end: Main-Class");
		
		
		emit.emitLabel(".ERROR_EXIT");
		emit.emit("movl", "STACK_PT", STACK_REG );
		emit.emit("movl", "BASE_PT", BASE_REG );
		emit.emitRaw("ret");
		

		for (ClassDecl ast : astRoots) {
			sg.gen(ast);
		}
		
		
		
	}
	
	protected void initMethodData() {
		{
			rm.initRegisters();
		}
	}


	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit.emit("movl", "$0", Register.EAX);
		emit.emitRaw("leave");
		emit.emitRaw("ret");
	}
}