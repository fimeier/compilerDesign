/* A simple TicTacToe variant to dest drive
   object and array handling, inheritance
   and the behavior of the compiler with a longer program,
   .... and each project needs a game. :-)

   The program is not written for speed but to test as many things of the Javali language as possible.

   Test should be accepted as correct!

   Input file:
   The first number of the input files lists the number of games (correct or faulty ones)
   listed below in the input file. However, each game needs to be complete up to the situation
   that the came loop terminates (i.e. a player has won or the board is full, or a player tried
   to set a field that was already used).

   currently, only visualization.
   player 1 and 2 sequentially  inputs next position according to
   1 2 3
   4 5 6
   7 8 9

   before start and after each step, the board is printed in format
   100
   210
   002

   if player 1 wins, an additional board filled with 1 is printed,
   and for player 2 accordingly.
   An empty line is printed after each board


   And yes, since a matrix is used as a basis class for the board,
   matrix multiplication is built into that class, too, which
   can be tested in an additional test program.

   lots of things are tested on purpose (see accessing fields and local variables
   directly), shadowing of local variables / parameters, i.e. the need of this
   in the constructors,...

   no array index checking on valid range at the moment.

   compact format check to have some boolean work done, too,
   and additionally some return from the middle of the function.


   additionally multiple inheritance tested
   and overriding of methods tested


    A method with return type void and name identical to class
    serves as constructor since there are no actual constructors.
    Such named constructors have the advantage to allow calling
    also the parent constructor since there is no super or parend
    key word.

   TheTransformers, 03/21/2017 Pirmin Schmid
*/


class Vector {
    int n;
    int[] v;

    // works as a constructor
    void Vector(int n, int default) {
        this.n = n;
        v = new int[n];
        fill(default);
    }

    void fill(int value) {
        int i;

        i = 0;
        while (i < n) {
            v[i] = value;
            i = i + 1;
        }
    }

    boolean contains(int value) {
        int i;

        i = 0;
        while (i < n) {
            if (v[i] == value) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    boolean compactOK() {
        int i, value;

        i = 0;
        while (i < n) {
            value = v[i];
            if (value < 0 || 9 < value) {
                return false;
            }
            i = i + 1;
        }

        // default
        return true;
    }

    void print() {
        print2(compactOK());
    }

    void print2(boolean compact) {
        int i;
        boolean nc;

        nc = !compact;
        i = 0;
        while (i < n) {
            write(v[i]);
            if (nc) {
                writeln();
            }
            i = i + 1;
        }
        writeln();
    }

    void set(int i, int value) {
        v[i] = value;
    }

    int get(int i) {
        return v[i];
    }
}


class Matrix {
    int m;
    Vector[] vectors;

    // works as a constructor
    void Matrix(int m, int n, int default) {
        Vector temp;
        int i;

        this.m = m;
        vectors = new Vector[n];
        i = 0;
        while (i < m) {
            temp = new Vector();
            temp.Vector(n, default);
            vectors[i] = temp;
            i = i + 1;
        }
    }

    void fill(int value) {
        int i;

        i = 0;
        while (i < m) {
            vectors[i].fill(value);
            i = i + 1;
        }
    }

    boolean contains(int value) {
        int i;

        i = 0;
        while (i < m) {
            if (vectors[i].contains(value)) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    boolean compactOK() {
        int i;

        i = 0;
        while (i < m) {
            if (!vectors[i].compactOK()) {
                return false;
            }
            i = i + 1;
        }

        // default
        return true;
    }

    void print() {
        boolean compact;
        int i;

        compact = compactOK();
        i = 0;
        while (i < m) {
            vectors[i].print2(compact);
            i = i + 1;
        }
        // additional free line
        writeln();
    }

    void set(int i, int j, int value) {
        vectors[i].set(j, value);
    }

    int get(int i, int j) {
        return vectors[i].get(j);
    }

    int rows() {
        return m;
    }

    int columns() {
        return vectors[0].n;
    }


    // the current matrix will hold the result of A * B
    // all 3 matrices must be different; no aliasing check
    // at the end, the function returns 'this' to allow nesting
    // of matrix multiplications
    // however, NO new memory is allocated
    // additionally, if multiplication is not possible due to
    // dimension mismatch of A, B and this, null is returned
    // thus, null is also tested on input parameters
    //
    // of course, use of matrix multiplication of 32 bit ints is limited
    // but it's a nice test case for nested loops, and easy to check.
    Matrix mult(Matrix A, Matrix B) {
        int i, j, k, sum;

        if (null == A || null == B) {
            return null;
        }

        if (rows() != A.rows() || columns() != B.columns()) {
            return null;
        }

        if (A.columns() != B.rows()) {
            return null;
        }

        i = 0;
        while (i < rows()) {
            j = 0;
            while (j < columns()) {
                sum = 0;
                k = 0;
                while (k < columns()) {
                    sum = sum + A.get(i, k) * B.get(k, j);
                    k = k + 1;
                }
                set(i, j, sum);
                j = j + 1;
            }
            i = i + 1;
        }

        return this;
    }
}


class SquareMatrix extends Matrix {

    void SquareMatrix(int n, int default) {
        Matrix(n, n, default);
    }

    void fillIdentity() {
        int i;
        i = 0;
        while (i < m) {
            set(i, i, 1);
            i = i + 1;
        }
    }
}


class Board extends SquareMatrix {

    void Board() {
        SquareMatrix(3, 0);
    }

    boolean hasWon(int player) {
        int i;

        // any row complete?
        i = 0;
        while (i < 3) {
            if (rowComplete(i, player)) {
                return true;
            }
            i = i + 1;
        }

        // any column complete?
        i = 0;
        while (i < 3) {
            if (columnComplete(i, player)) {
                return true;
            }
            i = i + 1;
        }

        // any diagonal complete? or false as default
        return diagonal1Complete(player) || diagonal2Complete(player);
    }

    boolean rowComplete(int i, int player) {
        int j;

        j  = 0;
        while (j < 3) {
            if (get(i, j) != player) {
                return false;
            }
            j = j + 1;
        }
        return true;
    }

    boolean columnComplete(int j, int player) {
        int i;

        i  = 0;
        while (i < 3) {
            if (get(i, j) != player) {
                return false;
            }
            i = i + 1;
        }
        return true;
    }

    boolean diagonal1Complete(int player) {
        return get(0,0) == player && get(1,1) == player && get(2,2) == player;
    }

    boolean diagonal2Complete(int player) {
        return get(0,2) == player && get(1,1) == player && get(2,0) == player;
    }

    boolean full() {
        int i, j;

        i = 0;
        while (i < 3) {
            j = 0;
            while (j < 3) {
                if (0 == get(i, j)) {
                    return false;
                }
                j = j + 1;
            }
            i = i + 1;
        }
        return true;
    }


    // @override
    void set(int i, int j, int value) {
        if (0 == get(i, j)) {
            vectors[i].set(j, value);
        } else {
            vectors[i].set(j, 9); // error value
        }
    }
}


class Main {
    Board b;

    boolean runPlayer(int player) {
        int pos, row, column, n;
        Matrix m;

        m = b; // test assignment to parent type and memory manager

        n = 3;
        pos = read();
        pos = pos - 1; // adjust from 1-9 to 0-8

        row = pos / n;     // the divrem optimizer can optimize this
        column = pos % n;

        if (1 == player) {
            b.set(row, column, player);
        } else {
            // test of polymorphism (see: set is overridden)
            m.set(row, column, player);
        }

        // test type casting from base type to inherited type
        b = (Board) m;

        b.print();

        return b.hasWon(player);
    }

    void runGame() {
        int winner; // starts with 0 and switches to 1 or 2 dependent on winner
        int currentPlayer;

        // reset the board
        b.fill(0);
        b.print();

        winner = 0;
        currentPlayer = 1;
        while (0 == winner && !b.full() && !b.contains(9)) {
            if (runPlayer(currentPlayer)) {
                winner = currentPlayer;
            }

            // toggle between player 1 and 2 (note sum of them is always 3)
            currentPlayer = 3 - currentPlayer;
        }

        // create "winner matrix"
        // note: this could be accomplished much easier
        // test for contains 9 and then set winner to 9 in this case
        // and then just fill the board with winner variable
        // However, with the current construction, we can test some
        // nested if conditions.
        if (1 == winner) {
            b.fill(1);
        } else {
            if (2 == winner) {
                b.fill(2);
            } else {
                if (b.contains(9)) {
                    b.fill(9);
                } else {
                    b.fill(0);
                }
            }
        }

        // output final evaluation
        // -> was moved to the main function loop just for testing purpose (i.e. class field b works properly)
    }

    void main() {
        int i, n;

        // one board for all games
        b = new Board();
        b.Board(); // constructor

        // how many games are stored in the input file?
        n = read();
        i = 0;
        while (i < n) {
            runGame();

            // output final evaluation
            // 1, 2 winners, 0 no winner, 9 error when setting a value that was already set
            b.print();

            i = i + 1;
        }
    }
}
