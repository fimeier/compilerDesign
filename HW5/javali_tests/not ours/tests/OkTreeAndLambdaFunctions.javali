/* a test program that is again a bit longer / more complex

   expected output:

   first tree (order Less)
   - count
   - depth
   - all values in order

   second tree (order Greater)
   - count
   - depth
   - all values in order


   code:
   it has a simple binary tree implementation
   - allows a lambda function for cmp operation
   - allows printing pre-/in-/postorder
   - gets depth and count
   - uses lambda functions for action and reduction to do so

   lambda functions are defined as children of a pre-defined lambda
   classes that offer an apply method of given signature

   the "random generator" is built following the
   "Quick and Dirty Generator" of Press H et al. Numerical recipes
   for C++, 2nd ed. page 288.
   It does not fulfill any properties, and is in particular
   not fit for crypto. But it is simple enough to be used here.

   2017-05-16 Pirmin Schmid
*/


//--- random -------------------------------------------------------------------

class Random {
    int im, ia, ic, jran;

    // constructor
    void Random(int seed) {
        // constants from overflow at 2^30
        im = 134456;
        ia = 8121;
        ic = 28411;
        jran = seed % im;
        next();
    }

    int next() {
        jran = (jran * ia + ic) % im;
        return jran;
    }
}


//--- comparison lambdas --------------------------------------------------------

class CmpLambda {
    int apply(int a, int b) { return 0; }
}

class Less extends CmpLambda {
    int apply(int a, int b) {
        if (a < b) {
            return -1;
        }

        if (a > b) {
            return 1;
        }

        return 0;
    }
}

class Greater extends CmpLambda {
    int apply(int a, int b) {
        if (a > b) {
            return -1;
        }

        if (a < b) {
            return 1;
        }

        return 0;
    }
}


//--- action lambdas -----------------------------------------------------------

class ActionLambda {
    int apply(int key, int value) { return 0; }
}

class CountAction extends ActionLambda {
    int apply(int key, int value) {
        return 1;
    }
}

class DepthAction extends ActionLambda {
    int apply(int key, int value) {
        return 1;
    }
}

class PrintKeyAction extends ActionLambda {
    int apply(int key, int value) {
        write(key); writeln();
        return 0;
    }
}

class PrintValueAction extends ActionLambda {
    int apply(int key, int value) {
        write(value); writeln();
        return 0;
    }
}

class PrintBothAction extends ActionLambda {
    int apply(int key, int value) {
        write(key); writeln();
        write(value); writeln();
        return 0;
    }
}


//--- reduction lambdas --------------------------------------------------------

class ReductionLambda {
    int apply(int leftReturn, int myReturn, int rightReturn) { return 0; }
}

class NothingReduction extends ReductionLambda {}

class CountReduction extends ReductionLambda {
    int apply(int leftReturn, int myReturn, int rightReturn) {
        return leftReturn + myReturn + rightReturn;
    }
}

class DepthReduction extends ReductionLambda {
    int apply(int leftReturn, int myReturn, int rightReturn) {
        if (leftReturn > rightReturn) {
            return leftReturn + myReturn;
        } else {
            return rightReturn + myReturn;
        }
    }
}


//--- tree ---------------------------------------------------------------------

class Node {
    CmpLambda cmpOp;
    Node left, right;
    int key, value;

    // "constructor"
    void Node(CmpLambda cmpOp, int key, int value) {
        this.cmpOp = cmpOp;
        left = null;
        right = null;
        this.key = key;
        this.value = value;
    }


    void add(Node n) {
        int cmp;

        // -1 -> left, 0 -> replace, 1 -> right
        cmp = n.compare(this);

        if (cmp == 0) {
            value = n.getValue();
            return;
        }

        if (cmp < 0) {
            if (left == null) {
                left = n;
            } else {
                left.add(n);
            }
        } else {
            if (right == null) {
                right = n;
            } else {
                right.add(n);
            }
        }
    }

    Node getLeft() {
        return left;
    }

    Node getRight() {
        return right;
    }

    // returns: this.key cmpOp other.key
    int compare(Node other) {
        return cmpOp.apply(this.key, other.getKey());
    }

    int getKey() {
        return key;
    }

    int getValue() {
        return value;
    }


    int runPreOrder(ActionLambda action, ReductionLambda reduce) {
        int l, m, r;

        m = action.apply(key, value);

        if (left != null) {
            l = left.runPreOrder(action, reduce);
        } else {
            l = 0;
        }

        if (right != null) {
            r = right.runPreOrder(action, reduce);
        } else {
            r = 0;
        }

        return reduce.apply(l, m, r);
    }

    int runInOrder(ActionLambda action, ReductionLambda reduce) {
        int l, m, r;

        if (left != null) {
            l = left.runInOrder(action, reduce);
        } else {
            l = 0;
        }

        m = action.apply(key, value);

        if (right != null) {
            r = right.runInOrder(action, reduce);
        } else {
            r = 0;
        }

        return reduce.apply(l, m, r);
    }

    int runPostOrder(ActionLambda action, ReductionLambda reduce) {
        int l, m, r;

        if (left != null) {
            l = left.runPreOrder(action, reduce);
        } else {
            l = 0;
        }

        if (right != null) {
            r = right.runPreOrder(action, reduce);
        } else {
            r = 0;
        }

        m = action.apply(key, value);

        return reduce.apply(l, m, r);
    }
}

class Tree {
    CmpLambda cmpOp;
    ActionLambda printKeyAction, printValueAction, printBothAction, countAction, depthAction;
    ReductionLambda printReduce, countReduce, depthReduce;
    Node root;

    void Tree(CmpLambda cmpOp) {
        this.cmpOp = cmpOp;

        // some caching to avoid rebuilding them
        preparePrintLambdas();
        prepareCountLambdas();
        prepareDepthLambdas();
    }

    void add(int key, int value) {
        Node n;
        n = new Node();
        n.Node(cmpOp, key, value);

        if (root == null) {
            root = n;
        } else {
            root.add(n);
        }
    }


    //--- count
    void prepareCountLambdas() {
        countAction = new CountAction();
        countReduce = new CountReduction();
    }

    int getCount() {
        if (root != null) {
            return root.runPostOrder(countAction, countReduce);
        } else {
            return 0;
        }
    }

    //--- depth
    void prepareDepthLambdas() {
        depthAction = new DepthAction();
        depthReduce = new DepthReduction();
    }

    int getDepth() {
        if (root != null) {
            return root.runPostOrder(depthAction, depthReduce);
        } else {
            return 0;
        }
    }

    //--- print
    void preparePrintLambdas() {
        printKeyAction = new PrintKeyAction();
        printValueAction = new PrintValueAction();
        printBothAction = new PrintBothAction();
        printReduce = new NothingReduction();
    }

    // 1 = key; 2 = value; 3 (currently just any other value) = booth
    void printPreOrder(int type) {
        ActionLambda action;
        if (type == 1) {
            action = printKeyAction;
        } else {
            if (type == 2) {
                action = printValueAction;
            } else {
                action = printBothAction;
            }
        }

        if (root != null) {
            root.runPreOrder(action, printReduce);
        }
    }

    // 1 = key; 2 = value; 3 (currently just any other value) = booth
    void printInOrder(int type) {
        ActionLambda action;
        if (type == 1) {
            action = printKeyAction;
        } else {
            if (type == 2) {
                action = printValueAction;
            } else {
                action = printBothAction;
            }
        }

        if (root != null) {
            root.runInOrder(action, printReduce);
        }
    }

    // 1 = key; 2 = value; 3 (currently just any other value) = booth
    void printPostOrder(int type) {
        ActionLambda action;
        if (type == 1) {
            action = printKeyAction;
        } else {
            if (type == 2) {
                action = printValueAction;
            } else {
                action = printBothAction;
            }
        }

        if (root != null) {
            root.runPostOrder(action, printReduce);
        }
    }
}


//--- Main ---------------------------------------------------------------------

class Main {
    Random r;
    Tree t1, t2;

    void init() {
        CmpLambda cmpOp;

        r = new Random();
        r.Random(42);

        cmpOp = new Less();
        t1 = new Tree();
        t1.Tree(cmpOp);

        cmpOp = new Greater();
        t2 = new Tree();
        t2.Tree(cmpOp);
    }

    void fill(Tree t, int n) {
        int i, key, value;
        i = 0;
        while (i < n) {
            key = r.next();
            value = key; // just use the tree as a set at the moment
            t.add(key, value);
            i = i + 1;
        }
    }

    void print(Tree t) {
        write(t.getCount()); writeln();
        write(t.getDepth()); writeln();
        t.printInOrder(1);
    }

    void main() {
        init();
        fill(t1, 100);
        fill(t2, 100);
        print(t1);
        print(t2);
    }
}
